Драйвер STM32 HAL для беспроводного модуля LoRa SX1278
309 Ответов


Беспроводной связи на большие расстояния уделяется все больше и больше внимания. Сегодня я хотел бы поделиться с вами своим опытом работы с модулем LoRa — SX1278, а также с приводом для этого устройства.


Обновление!
Недавно я опубликовал дополнительный драйвер, который можно использовать с этим и подобными модулями LoRa на Raspberry Pi. Кроме того, в комплект поставки входит оболочка Python, так что вы можете легко запустить свой проект с помощью этого драйвера. Здесь вы можете найти подробности — Драйвер LoRa для Raspberry Pi с оболочкой Python.

LoRa получила свое название от “Long Range”. Это запатентованная система связи, использующая технологию радиомодуляции с расширенным спектром chirp. Другими словами, она использует chirp для кодирования части информации. Что действительно интересно в LoRa, так это тот факт, что он может передавать данные на очень большие расстояния. Под "очень большими расстояниями" я подразумеваю более пары километров, а иногда и больше, и все это делается очень энергоэффективно.



Я решил поработать над модулем LoRa SX1278. Это доступный радиомодуль, который предлагает не только LoRa, но и другие типы модуляции, такие как FSK. Тестовой платформой является плата разработки STM32F103C8T6.

Обязательное условие
Вам понадобятся две платы, оснащенные микроконтроллером STM32F103C8T6, и два модуля SX1278.



One of the boards will work as master and the other one will work as slave. Master is sending data to slave. Both boards have the same firmware. The mode in which the board is working in is determined by the state of input pin PB2.



Выше вы можете увидеть снимок экрана из CubeMX, где настроены контакты MCU.

Чтобы действительно видеть, что передается по радио, использовался SWV-интерфейс. Для этого вам нужен отладчик, предпочтительно ST-Link V2, с поддержкой SWV. Иногда, когда вы хотите воспользоваться SWV, он не работает "из коробки". Наиболее вероятная причина этого в том, что прошивка отладчика устарела. Пожалуйста, не забудьте заранее обновить прошивку ST-Link.

Подключение
Модуль должен быть подключен к плате MCU следующими контактами:

ВЫВОД MCU	ВЫВОД SX1278	ОПИСАНИЕ
PA4	NSS	Чип SPI–выберите
PA5	SCK	SPI SCK
PA6	ИТАК	SPI MISO
PA7	SI	SPI MOSI
PB0	DIO0	Вывод индикатора прерывания LoRa (для режима приемника)
PB1	ПЕРВЫЙ	Сброс LoRa
——-	———-	———–
VDD	VCC	+3V3
VSS	GND	GND
SX1278 взаимодействует с микроконтроллером STM32 через SPI, это PA4, PA5, PA6 и PA7. Есть два других логических вывода — PB0, который является DIO0 радиомодуля, и PB1, который является выводом сброса этого модуля. Значение ввода сброса, если очевидно, то не является DIO0. Он используется для определения состояния модуля LoRa. Если выходной сигнал DIO0 высокий, это означает, что получены данные и MCU может их прочитать. MCU можно настроить на обнаружение переднего фронта, чтобы вызвать немедленное действие по считыванию данных. Однако в этом примере использовался опрос (проверка вручную, является ли DIO0 высоким).

Сборник
Пример был подготовлен для IDE SW4STM32. Однако ничто не мешает использовать другую IDE, например, TrueSTUDIO – Atollic.

Запустить
После перепрошивки изображения вам следует обратить внимание на порт PB2. Он настроен как входной, и в зависимости от его состояния плата загружается как master или как slave. Для режима master PB2 должен быть установлен высоко. Для подчиненного режима PB2 должен быть установлен на низком уровне.

Все сообщения передаются через перенаправленную функцию printf () в SWV. Для чтения сообщений у вас должна быть установлена утилита ST-Link. Там вы можете выбрать Printf через SWO viewer и установить нужную частоту.

Прежде чем начать передачу и прием данных через LoRa, вам необходимо настроить драйвер. Ниже приведен пример того, как это сделать.

//определите необходимые структуры
SX1278_hw_t SX1278_hw;
SX1278_t SX1278;

//инициализируйте аппаратное обеспечение для модуля LoRa
SX1278_hw.dio0.порт = DIO0_GPIO_Port;
SX1278_hw.dio0.pin = DIO0_Pin;
SX1278_hw.nss.port = NSS_GPIO_Port;
SX1278_hw.nss.pin = NSS_Pin;
SX1278_hw.reset.port = RESET_GPIO_Port;
SX1278_hw.reset.pin = RESET_Pin;
SX1278_hw.spi = &hspi1;

//логика инициализации модуля LoRa
SX1278.hw = &SX1278_hw;

//настройка модуля 
printf ("Настройка модуля LoRa \r\n");
SX1278_begin(& SX1278, SX1278_433MHZ, SX1278_POWER_17DBM, SX1278_LORA_SF_8, 
 SX1278_LORA_BW_20_8 кГц, 10);
printf ("Настройка LoRaModule завершена");

//режим ввода передатчика (master) или приемника (slave) 
if (master == 1)
 ret = SX1278_LoRaEntryTx(&SX1278, 16, 2000);
еще 
 ret = SX1278_LoRaEntryRx(&SX1278, 16, 2000);
Приведенный пример работает обычным образом, главная плата постоянно отправляет сообщения, в то время как подчиненное устройство постоянно их считывает. Это просто, не так ли? Ниже был предоставлен фрагмент кода для прояснения ситуации.

while (1)
{ 
 if (master == 1) { 
 printf("Master ...\r\ n");
 HAL_Delay(2500);
 printf ("Отправка пакета ...\r \ n");

 message_length = sprintf (буфер, "Привет %d", сообщение);
 ret = SX1278_LoRaEntryTx(&SX1278, message_length, 2000);
 printf("Запись: %d\r\ n", ret);

 printf ("Отправка %s\r\n", буфер);
 ret = SX1278_LoRaTxPacket(&SX1278, буфер (uint8_t *), длина сообщения, 
 2000);
 message += 1;

 printf ("Передача: %d\ r\n", ret);
 printf ("Посылка отправлена...\ r\ n");

 } else {
 printf ("Подчиненный ...\ r \ n");
 HAL_Delay (1000);
 printf ("Получение пакета ...\ r\ n");

 ret = SX1278_LoRaRxPacket (&SX1278);
 printf ("Получено: %d\r\n", ret);
 if (ret > 0) {
 SX1278_read(&SX1278, (uint8_t *) buffer, ret);
 printf("Содержимое (%d): %s\r\ n", ret, буфер);
 }
 printf ("Посылка получена ...\r\n");
 }
}
Рабочий пример
Ниже вы можете увидеть два снимка экрана. На первом изображении показан журнал сеанса master. На втором изображении показан журнал сеанса slave.

Мастер:



Подчинение:



Исходный код
Если вы достаточно заинтригованы, вы можете скачать драйвер или пример целиком. Оба доступны на моем github. Драйвер написан на C, и его можно легко перенести на другие цели. Кроме того, аппаратный уровень был отделен от логики драйвера, поэтому его перенос не представляет проблем.
